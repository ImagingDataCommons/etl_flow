#
# Copyright 2015-2021, Institute for Systems Biology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This script compares our hierarchical hashes with those generated by NBIA. This is
# mostly to test NBIA progress.

import sys
import os
import argparse
import hashlib
from logging import INFO
from utilities.tcia_helpers import get_hash, get_access_token, get_images_with_md5_hash, get_images_with_md5_hash_nlst,\
    get_TCIA_patients_per_collection, get_TCIA_studies_per_patient, get_TCIA_series_per_study, NBIA_AUTH_URL, \
    get_hash_nlst, NLST_AUTH_URL, refresh_access_token
from ingestion.utilities.utils import get_merkle_hash
from utilities.logging_config import successlogger, progresslogger, errlogger
import settings
from google.cloud import bigquery
import zipfile
import io
import pydicom

from idc.models import Base, Version, All_Collections
from sqlalchemy.orm import Session


from python_settings import settings

from sqlalchemy import create_engine
from sqlalchemy_utils import register_composites


# Get a list of instance md5 hashes from NBIA
def get_instance_hashes(series_instance_uid, collection_id, access_token):
    if collection_id == 'NLST':
        zip_file = io.BytesIO(get_images_with_md5_hash_nlst(series_instance_uid, access_token).content)
    else:
        zip_file = io.BytesIO(get_images_with_md5_hash(series_instance_uid, access_token).content)
    zipfile_obj = zipfile.ZipFile(zip_file)
    try:
        md5_hashes = [row.decode().split(',')  for row in zipfile_obj.open("md5hashes.csv").read().splitlines()[1:]]
    except KeyError as exc:
        print(exc)
        return

    for instance in md5_hashes:
        with zipfile_obj.open(instance[0]) as dcm_obj:
            instance.append(pydicom.dcmread(dcm_obj, stop_before_pixels=True).SOPInstanceUID)

    return (md5_hashes, zipfile_obj)

def compare_instance_hashes(access_token, refresh_token, cur, args, collection, patient, study, series):
    idc_instances = series.instances
    nbia_instances, zipfile_obj = get_instance_hashes(series.series_instance_uid, collection.collection_id, access_token)

    if len(nbia_instances) != len(idc_instances):
        progresslogger.info('            %-32s Differing instance count for series: IDC: %s, NBIA: %s',
                            series.series_instance_uid,
                            len(idc_instances), len(nbia_instances))

    only_idc = []
    only_tcia = []
    if not set([instance.sop_instance_uid for instance in idc_instances]) == \
           set([instance[2] for instance in nbia_instances]):
        progresslogger.info("i>>           Different set of instances")
        if only_idc := set([instance.sop_instance_uid for instance in idc_instances]) - set([instance[2] for instance in nbia_instances]):
            progresslogger.info("i>>             Instances that are only in IDC")
            for instance in only_idc:
                progresslogger.info(f"i>>              {instance}")
        if only_tcia := set([instance[2] for instance in nbia_instances]) - set([instance.sop_instance_uid for instance in idc_instances]):
            progresslogger.info("i>>             Instances that are only in TCIA")
            for instance in only_tcia:
                progresslogger.info(f"i>>              {instance}")

    for idc_instance in [ idc_instance for idc_instance in idc_instances if idc_instance.sop_instance_uid not in only_tcia]:
        nbia_instance = next(nbia_instance for nbia_instance in nbia_instances if nbia_instance[2]==idc_instance.sop_instance_uid)
        md5 = hashlib.md5()
        md5.update(zipfile_obj.open(nbia_instance[0]).read())
        pyhash = md5.hexdigest()
        idc_hash = idc_instance.hash
        nbia_hash = nbia_instance[1]

        if not args.only_mismatches or pyhash != idc_hash:
            progresslogger.info('i:                %-32s IDC: %s, NBIA: %s; %s', idc_instance.sop_instance_uid, idc_instance.hash,
                            nbia_instance[1], idc_hash == nbia_hash)


def compare_series_hashes(access_token, refresh_token, cur, args, collection, patient, study):
    tcia_series = get_TCIA_series_per_study(collection.collection_id, patient.submitter_case_id, study.study_instance_uid)

    idc_series = study.seriess
    only_idc = []
    if args.series:
        idc_series = [ series for series in idc_series if series.series_instance_uid in args.series]
    else:
        if not set([series.series_instance_uid for series in idc_series]) == set([series['SeriesInstanceUID'] for series in tcia_series]):
            progresslogger.info("st>>           Different set of series")
            if only_idc := set([series.series_instance_uid for series in idc_series]) - set([series['SeriesInstanceUID'] for series in tcia_series]):
                progresslogger.info("st>>             Series that are only in IDC")
                for series in only_idc:
                    progresslogger.info(f"st>>              {series}")
            if only_tcia := set([series['SeriesInstanceUID'] for series in tcia_series]) - set([series.series_instance_uid for series in idc_series]):
                progresslogger.info("st>>             Series that are only in TCIA")
                for series in only_tcia:
                    progresslogger.info(f"st>>              {series}")

    tcia_series = sorted(tcia_series, key=lambda id: id['SeriesInstanceUID'])
    for series in [series for series in idc_series if series.series_instance_uid not in only_idc]:
        try:
            if collection.collection_id == 'NLST':
                result = get_hash_nlst({'SeriesInstanceUID': series.series_instance_uid},
                    access_token=access_token)
            else:
                result = get_hash({'SeriesInstanceUID': series.series_instance_uid},
                    access_token=access_token)

            if result.status_code == 504:
                progresslogger.info('se:            %-32s IDC: %s, error: %s, reason: %s', study.study_instance_uid, series.series_instance_uid, result.status_code,
                                result.reason)

            nbia_hash = result.text
            idc_hash = series.hashes.tcia
            if 'series' in args.log_level:
                if not args.only_mismatches or idc_hash != nbia_hash:
                    progresslogger.info('se:            %-32s IDC: %s, NBIA: %s; %s', study.study_instance_uid, series.series_instance_uid, nbia_hash, idc_hash==nbia_hash)
            if not args.stop_expansion == 'series':
                if idc_hash != nbia_hash or args.expand_all:
                    if args.stop and (nbia_hash == 'd41d8cd98f00b204e9800998ecf8427e' or nbia_hash == ""):
                        if 'series' in args.log_level:
                            progresslogger.info('se:        %-32s Skip expansion', "")
                    else:
                        if series.series_instance_uid not in only_idc:
                            compare_instance_hashes(access_token, refresh_token, cur, args, collection, patient, study, series)

        except TimeoutError as esc:
            progresslogger.info('se:%-32s IDC: %s, error: %s, reason: %s', study.study_instance_uid, series.series_instance_uid, result.status_code, result.reason)


def compare_study_hashes(access_token, refresh_token, sess, args, collection, patient):
    tcia_studies = get_TCIA_studies_per_patient(collection.collection_id, patient.submitter_case_id)
    idc_studies = patient.studies
    only_idc = []
    if args.studies:
        idc_studies = [study for study in idc_studies if study.study_instance_uid in args.studies]
    else:
        only_tcia = []
        if not set([study.study_instance_uid for study in idc_studies]) == set([study['StudyInstanceUID'] for study in tcia_studies]):
            progresslogger.info("p>>         Different set of studies")
            if only_idc := set([study.study_instance_uid for study in idc_studies]) - set([study['StudyInstanceUID'] for study in tcia_studies]):
                progresslogger.info("p>>           Studies that are only in IDC")
                for study in only_idc:
                    progresslogger.info(f"p>>            {study}")
            if only_tcia := set([study['StudyInstanceUID'] for study in tcia_studies]) - set([study.study_instance_uid for study in idc_studies]):
                progresslogger.info("p>>           Studies that are only in TCIA")
                for study in only_tcia:
                    progresslogger.info(f"p>>            {study}")

    for study in [study for study in idc_studies if study.study_instance_uid not in only_idc]:
        try:
            if collection.collection_id == 'NLST':
               result = get_hash_nlst({'StudyInstanceUID': study.study_instance_uid},
                        access_token=access_token)
            else:
                result = get_hash({'StudyInstanceUID': study.study_instance_uid},
                        access_token=access_token)
            if result.status_code == 504:
                progresslogger.info('st:        %-32s IDC: %s, error: %s, reason: %s', patient.submitter_uid, study.study_instance_uid, result.status_code,
                                result.reason)

            nbia_hash = result.text
            idc_hash = study.hashes.tcia
            if 'study' in args.log_level:
                if not args.only_mismatches or idc_hash != nbia_hash:
                    progresslogger.info('st:        %-32s IDC: %s, NBIA: %s; %s', study.study_instance_uid, nbia_hash, idc_hash, idc_hash==nbia_hash)
            if not args.stop_expansion == 'study':
                if idc_hash != nbia_hash or args.expand_all:
                    if args.stop and (nbia_hash == 'd41d8cd98f00b204e9800998ecf8427e' or nbia_hash == ""):
                        if 'study' in args.log_level:
                            progresslogger.info('st:        %-32s Skip expansion', "")
                    else:
                        if study.study_instance_uid not in only_idc:
                            compare_series_hashes(access_token, refresh_token, sess, args, collection, patient, study)
        except TimeoutError as esc:
            progresslogger.info('st:%-32s IDC: %s, error: %s, reason: %s', patient.submitter_case_id, study.study_instance_uid, result.status_code, result.reason)

def validate_idc_collection_hash(collection):
    idc_patient_hashes = [patient.hashes.tcia for patient in collection.patients]
    idc_collection_hash = get_merkle_hash(idc_patient_hashes)
    if idc_collection_hash != collection.hashes.tcia:
        print('idc collection hash hierarchically incorrect')
    else:
        print ('idc collection hash hierarchically correct')

def compare_patient_hashes(access_token, refresh_token, sess, args, collection):
    tcia_patients = get_TCIA_patients_per_collection(collection.collection_id)

    idc_patients = [patient  for patient in collection.patients if patient.sources.tcia==True]
    only_idc = []
    if args.patients:
        idc_patients = [patient for patient in idc_patients if patient.submitter_case_id in args.patients]
    else:
        only_tcia = []
        if not set([patient.submitter_case_id for patient in idc_patients]) == set([patient['PatientId'] for patient in tcia_patients]):
            progresslogger.info("c>>       Different set of patients")
            if only_idc := set([patient.submitter_case_id for patient in idc_patients]) - set([patient['PatientId'] for patient in tcia_patients]):
                progresslogger.info("c>>         Patients that are only in IDC")
                for patient in only_idc:
                    progresslogger.info(f"c>>         {patient}")
            if only_tcia := set([patient['PatientId'] for patient in tcia_patients]) - set([patient.submitter_case_id for patient in idc_patients]):
                progresslogger.info("p>>         Patients that are only in TCIA")
                for patient in only_tcia:
                    progresslogger.info(f"c>>         {patient}")

    for patient in [patient for patient in idc_patients if patient.submitter_case_id not in only_idc]:
        access_token, refresh_token = get_access_token(auth_server=NBIA_AUTH_URL)
        try:
            # progresslogger.info('{}    {:32}'.format(n, patient.submitter_case_id))
            if collection.collection_id == 'NLST':
                result = get_hash_nlst(
                {'Collection': collection.collection_id, 'PatientID': patient.submitter_case_id}, access_token=access_token)
            else:
                result = get_hash(
                {'Collection': collection.collection_id, 'PatientID': patient.submitter_case_id}, access_token=access_token)
            if result.status_code == 504:
                progresslogger.info('p:    %-32s error: %s, reason: %s', patient.submitter_case_id, result.status_code,
                                result.reason)

            nbia_hash = result.text
            idc_hash = patient.hashes.tcia
            if 'patient' in args.log_level:
                if not args.only_mismatches or idc_hash != nbia_hash:
                    progresslogger.info('p:     {:32} IDC: {}, NBIA: {}; {}'.format(patient.submitter_case_id, idc_hash, nbia_hash, idc_hash==nbia_hash))
            if not args.stop_expansion == 'patient':
                if idc_hash != nbia_hash or args.expand_all:
                    if args.stop:
                        if 'patient' in args.log_level:
                            progresslogger.info('p:    %-32s Skip expansion', "")
                    else:
                        if patient.submitter_case_id not in only_idc:
                            compare_study_hashes(access_token, refresh_token, sess, args, collection, patient)
        except TimeoutError as esc:
            progresslogger.info('p:%-32s error: %s, reason: %s', patient.submitter_case_id, result.status_code, result.reason)

def compare_collection_hashes(sess, args):

    query = f"""
        SELECT tcia_api_collection_id, collection_hash
        FROM collection{args.suffix}
        WHERE idc_version_number={args.version}
        ORDER BY tcia_api_collection_id
      """
    version = sess.query(Version).filter(Version.version == args.version).first()
    all_collections = version.collections
    all_collections = sorted(version.collections, key=lambda collection: collection.collection_id)

    # redacted_collections = [collection.tcia_api_collection_id for collection in
    #                         sess.query(All_Collections.tcia_api_collection_id).\
    #                         filter(All_Collections.dev_tcia_url=='idc-dev-redacted')]
    included_collections = [collection.tcia_api_collection_id for collection in
                            sess.query(All_Collections.tcia_api_collection_id). \
                                filter(All_Collections.dev_tcia_url.in_(('idc-dev-open', 'idc-dev-cr', 'idc-dev-defaced')))]

    if args.collections == []:
        collections = [collection for collection in all_collections if
                   collection.collection_id in included_collections]
    else:
        collections = [collection for collection in all_collections if
                   collection.collection_id in args.collections]

    skips = args.skips
    for collection in collections:
        collection_id = collection.collection_id
        if collection_id not in skips:
            if collection_id == 'NLST':
                access_token, refresh_token = get_access_token(auth_server=NLST_AUTH_URL)
            else:
                access_token, refresh_token = get_access_token(auth_server=NBIA_AUTH_URL)
            try:
                if collection_id == 'APOLLO':
                    result, access_token, refresh_token = get_hash({'Collection': 'APOLLO-5-LSCC'}, access_token=access_token, refresh_token=refresh_token)
                else:
                    if collection_id == 'NLST':
                        result = get_hash_nlst({'Collection': collection_id}, access_token=access_token)
                    else:
                        result = get_hash({'Collection': collection_id}, access_token=access_token)

                if result.status_code == 504:
                    progresslogger.info('c:%-32s IDC: %s, error: %s, reason: %s', collection_id, collection.hashes.tcia, result.status_code, result.reason)

                nbia_hash = result.text
                try:
                    idc_hash = collection.hashes.tcia
                    if 'collection' in args.log_level:
                        if not args.only_mismatches or idc_hash!=nbia_hash:
                            progresslogger.info('c:%-32s IDC: %s, NBIA: %s; %s', collection_id, collection.hashes.tcia, nbia_hash, idc_hash==nbia_hash)
                except:
                    idc_hash = ''
                    progresslogger.info('c:{:32} No IDC hash'.format(collection_id) )

                if not args.stop_expansion == 'collection':
                    if idc_hash != nbia_hash or args.expand_all:
                        if args.stop and (nbia_hash == 'd41d8cd98f00b204e9800998ecf8427e' or nbia_hash == ""):
                            if 'collection' in args.log_level:
                                progresslogger.info('%-32s Skip expansion', "")
                        else:
                            compare_patient_hashes(access_token, refresh_token, sess, args, collection)
            except TimeoutError as esc:
                progresslogger.info('c:%-32s IDC: %s, error: %s, reason: %s', collection_id, collection.hashes.tcia, result.status_code, result.reason)
        else:
            progresslogger.info('Skipping %-32s ', collection_id)



def compare_hashes(args):
    sql_uri = f'postgresql+psycopg2://{settings.CLOUD_USERNAME}:{settings.CLOUD_PASSWORD}@{settings.CLOUD_HOST}:{settings.CLOUD_PORT}/{args.db}'
    # sql_engine = create_engine(sql_uri, echo=True) # Use this to see the SQL being sent to PSQL
    sql_engine = create_engine(sql_uri)
    args.sql_uri = sql_uri # The subprocesses need this uri to create their own SQL engine

    # Enable the underlying psycopg2 to deal with composites
    conn = sql_engine.connect()
    register_composites(conn)

    with Session(sql_engine) as sess:
        compare_collection_hashes(sess, args)
        pass



if __name__ == '__main__':
    # rootlogger = logging.getLogger('root')
    # root_fh = logging.FileHandler('{}/logs/compare_hashes_log.log'.format(os.environ['PWD']))
    # # rootformatter = logging.Formatter('%(levelname)s:root:%(message)s')
    # rootformatter = logging.Formatter('%(message)s')
    # rootlogger.addHandler(root_fh)
    # root_fh.setFormatter(rootformatter)
    # rootlogger.setLevel(INFO)
    #
    # errlogger = logging.getLogger('root.err')
    # err_fh = logging.FileHandler('{}/logs/compare_hashes_err.log'.format(os.environ['PWD']))
    # errformatter = logging.Formatter('%(levelname)s:err:%(message)s')
    # errlogger.addHandler(err_fh)
    # err_fh.setFormatter(errformatter)
    #
    # version = settings.CURRENT_VERSION
    version = 16
    parser = argparse.ArgumentParser()
    # parser.add_argument('--db', default=f'idc_v{version}', help='Database to compare against')
    parser.add_argument('--db', default=f'idc_v{version}', help='Database to compare against')
    parser.add_argument('--suffix', default="")
    parser.add_argument('--stop_expansion', default="Pa", help="Level at which to stop expansion")
    parser.add_argument('--stop', default=False, help='Stop expansion if no hash returned by NBIA')
    parser.add_argument('--expand_all', default=False, help="Expand regardless of whether hashes match.")
    parser.add_argument('--ignore_differing_patient_counts', default=True)
    parser.add_argument('--only_mismatches', default=False, help='Only log mismatching hashes')
    parser.add_argument('--log_level', default=("collection, patient, study, series, instance"),
                        help='Levels at which to log')
    parser.add_argument('--collections', default=['CPTAC-HNSCC'], \
                        help='List of collections to compare. If empty, compare all collections')
    parser.add_argument('--patients', default = [],
                        help='List of patients to compare. If empty, compare all patients')
    parser.add_argument('--studies', default = [],
                        help='List of studies to compare. If empty, compare all studies')
    parser.add_argument('--series', default = [],
                        help='List of series to compare. If empty, compare all series')
    parser.add_argument('--skips', default=[])

    args = parser.parse_args()
    args.version = version


    print("{}".format(args), file=sys.stdout)

    compare_hashes(args)
